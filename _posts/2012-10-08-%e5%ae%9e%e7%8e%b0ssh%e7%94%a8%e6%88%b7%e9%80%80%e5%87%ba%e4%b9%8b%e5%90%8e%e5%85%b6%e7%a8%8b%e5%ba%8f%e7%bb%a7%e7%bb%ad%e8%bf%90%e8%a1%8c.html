---
layout: post
title: "实现ssh用户退出之后其程序继续运行"
categories:
- LINUX
- STUDYING
tags:
- screen
- ssh
- "守护程序"
status: publish
type: post
published: true
meta:
  _edit_last: '1'
author:
  login: tinet
  email: tinetkiller@gmail.com
  display_name: Tinet
  first_name: ''
  last_name: ''
---
<p>　　这两天在搞一个破解密码的测试程序，采用的是暴力破解方式。于是想到在实验室的一台旁路服务器上运行程序，但是存在一个问题，要想程序不停的跑，用户必需保持在线状态，泥马，这程序跑几天都不一定能出结果呢，拿我这老是无故蓝屏死机的电脑不是作死吗！于是到网上搜了下如何实现用户logout之后其程序保持运行。<br />
　　基本有两种方式，一种是用nohup,但这种方式很多人反应有些问题，具体什么问题，秉乘实用主义的心态我就不去深究了，于是这个方法直接PAAS掉。还有一种被大家比较认可的方式就是用screen了，那么screen是什么呢？screen是一个可以在多个进程之间多路复用一个物理终端的全屏窗口管理器。Screen中有会话的概念，用户可以在一个screen会话中创建多个screen窗口，在每一个screen窗口中就像操作一个真实的telnet/SSH连接窗口那样。看起来很强大的样子，但这里只想对其最基本的功能做一下记录，以备后来之需。<br />
　　假设现在我想运行一个getpasswd程序，要达到我最初的目的，只需一个条语句OK。<br />
　　screen -dmS SCREENNAME PATH／TO／RUN。<br />
　　要查看运行状态的话用这条命令：screen -r SCREENNAME。<!--more--><br />
　　再回到之前的界面用ctrl+a+d组合键即可。<br />
　　查看screen的会话列表用screen -ls命令。<br />
　　常用快捷键：<br />
　　Ctrl+a c ：在当前screen会话中创建窗口<br />
　　Ctrl+a w ：窗口列表<br />
　　Ctrl+a n ：下一个窗口<br />
　　Ctrl+a p ：上一个窗口<br />
　　Ctrl+a 0-9 ：在第0个窗口和第9个窗口之间切换<br />
附screen帮助文档：</p>
<p>Use: screen [-opts] [cmd [args]]<br />
or: screen -r [host.tty]</p>
<p>Options:<br />
-4 Use IPv4.<br />
-6 Use IPv6.<br />
-a Force all capabilities into each window's termcap.<br />
-A -[r|R] Adapt all windows to the new display width &amp; height.<br />
-c file Read configuration file instead of '.screenrc'.<br />
-d (-r) Detach the elsewhere running screen (and reattach here).<br />
-dmS name Start as daemon: Screen session in detached mode.<br />
-D (-r) Detach and logout remote (and reattach here).<br />
-D -RR Do whatever is needed to get a screen session.<br />
-e xy Change command characters.<br />
-f Flow control on, -fn = off, -fa = auto.<br />
-h lines Set the size of the scrollback history buffer.<br />
-i Interrupt output sooner when flow control is on.<br />
-l Login mode on (update /var/run/utmp), -ln = off.<br />
-list or -ls. Do nothing, just list our SockDir.<br />
-L Turn on output logging.<br />
-m ignore $STY variable, do create a new screen session.<br />
-O Choose optimal output rather than exact vt100 emulation.<br />
-p window Preselect the named window if it exists.<br />
-q Quiet startup. Exits with non-zero return code if unsuccessful.<br />
-r Reattach to a detached screen process.<br />
-R Reattach if possible, otherwise start a new session.<br />
-s shell Shell to execute rather than $SHELL.<br />
-S sockname Name this session .sockname instead of ...<br />
-t title Set title. (window's name).<br />
-T term Use term as $TERM for windows, rather than "screen".<br />
-U Tell screen to use UTF-8 encoding.<br />
-v Print "Screen version 4.00.03 (FAU) 23-Oct-06".<br />
-wipe Do nothing, just clean up SockDir.<br />
-x Attach to a not detached screen. (Multi display mode).<br />
-X Execute as a screen command in the specified session.</p>
